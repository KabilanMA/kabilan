---
layout: post
title: Compilers
date: 2025-04-10 06:01:00
description: A Record Keeping of Compiler Learning Materials
tags: formatting code toc incomplete
categories: notes
thumbnail: assets/img/gdb.png
giscus_comments: true
related_posts: false
toc:
  beginning: true

---

## Introduction
---

Compilers are human-machine translators that transform human-readable code into machine-readable programs. Compilers are like our intelligent friend who speaks multiple languages and helps us get around in a foreign country. You don't need to learn the foreign language to explore the city, you only need to develop the skills to communicate properly with your intelligent friend and make him do whatever you want (not intended in a manipulative way! maybe just a little). We’ve spent around 70 years developing the perfect compiler, and we still haven’t reached a mature stage, because there’s no perfect way to communicate with your friend in all scenarios. 

I’m personally an introverted person, which means it has always been very difficult for me to make new friends. I still have friends who have been with me for more than 15 years. Now, I’ve decided to learn how to make new friends, and the first step is to develop my communication skills. As the first part of that journey, I’m going to learn how to talk to a computer, just like any nerdy, introverted person would do. No, it’s not about LLMs, because I don’t want to learn English to speak with a Chinese person. I’m going to build a compiler while learning about its intricate parts and technical details.

What a weird way to start a project! I’m going to use this as an entry for record-keeping.

---

#### Things I should know
1. How to take all the English letters, numbers, and symbols—and make sense of them.
2. How to map what each letter, number, or symbol means—and how to even understand what counts as a number versus an English character.
3. What machine code is, and what it looks like.
4. How to turn all of my program code into machine code.
5. How the compiler knows that I’ve made a mistake in the program before converting it into machine code.

So, what do I know as I start this record?
**Nothing!** Just a few tiny details about compilers, thanks to my experience using different compilers for C/C++ projects.
What an idiot I am! I’ve been using compilers for so long without even making an effort to understand how they work.

---

#### Where do I start

The main part of learning is asking the right questions and knowing what you don’t know. So my first question is: *How do we take all the English letters, numbers, and symbols—and make sense of them?*

It’s just like learning a new language. You always start with grammar. So I’m also going to start with the concept of grammar and how it helps answer Question 1.


## Grammar

Grammar is the set of rules that define how words are arranged to form meaningful sentences in a language. Its purpose is to ensure clear and consistent communication by organizing words in a structured, understandable way. Therefore, to build any programming language that compilers can understand, we first have to define its grammar. Again, a question arises: What does grammar look like? Does it have verbs or subjects, like in natural languages? To understand this, we need to formally define what a formal grammar looks like in the context of a programming language.

I remember studying something like this during my undergraduate Theory of Computation class. It's time to refresh that memory.

> A formal grammar is a mathematical specification of a language’s syntax, typically defined as a 4‑tuple __G=(N,Σ,P,S)__ where __N__ is a finite set of nonterminal symbols, __Σ__ a set of terminal symbols (disjoint from __N__), __P__ a set of production rules, and __S ∈ N__ the start symbol

Oh! That’s a lot to digest. I don’t even know what this means at this point. Let’s break it down, part by part, and understand all the small details to fully grasp what it really means.


<ol>
    <li>
        <em>A formal grammar is a mathematical specification of a language’s syntax</em><br>
        Syntax refers to the specific rules that dictate the structure and arrangement of symbols and words in a programming language. Therefore, mathematically specifying this syntax is what is defined as a formal grammar. <br><br>
    </li>
    <li>
        <em>typically defined as a 4‑tuple <strong>G=(N,Σ,P,S)</strong></em><br>
        Grammar is formally defined as a tuple of four elements, each specifying a set of features/rules of a programming language. <br><br>
    </li>
    <li>
        <em><strong>N</strong> is a finite set of nonterminal symbols</em>.<br>
        There are a lot of things in this small sentence. Let's break it down. First, <em>what are non-terminal symbols?</em>, <em>what other symbols are there?</em>, <em>why does it have to be finite?</em> and <em>what does finite mean?</em> <br><br>
        <ol>
            <li>
                <em>what are non-terminal symbols?, what other symbols are there?</em> <br>When writing grammar rules, we use two types of symbols: <strong>non-terminal symbols</strong> and <strong>terminal symbols</strong>. <strong>Terminal symbols</strong> are the actual characters or tokens that appear in your program and cannot be broken down any further.<br><br>
                A few examples of non-terminal symbols in a Python-like programming language are:<br>
                <pre><code>if, else, print, (, ), +, -, identifier, number</code></pre>
                <strong>Non-terminal Symbols</strong> are placeholders for patterns or structures made up of terminals or other non-terminals.<br>
                <pre><code>print(3+5)</code></pre>
                Let’s take the above as a simple program written in our own programming language. Now, let’s see how the terminals and non-terminals would make up the grammar.<br>
                <pre><code>Program    --> Statement<br>Statement  --> "print" "(" Expression ")"<br>Expression --> Term "+" Term<br>Term       --> number</code></pre>
                Here, our Program is <code>print(3+5)</code>, which is a non-terminal symbol. According to our grammar, it is made up of terminal symbols such as <code>print</code>, <code>(</code>, and <code>)</code>, and a non-terminal symbol called <code>Expression</code>. The <code>Expression</code> here represents <code>3+5</code>, which is itself a combination of the terminal symbol <code>+</code> and non-terminal symbols like <code>Term</code>. <code>Term</code> is a non-terminal symbol that ultimately represents a terminal symbol, <code>number</code>. Refer the image below for better clarity.<br>
                <p style="text-align: center;">
                    <img src="/assets/img/compiler/terminal-non-terminal.png" alt="Terminal AND Non-terminal" style="max-width: 100%; border-radius: 8px;">
                </p>
                <br>
                Each statement in the grammer above is also known as <strong>Production</strong> and these statements are also know as <strong>Production Rules</strong> We will look into this later.
            </li>
            <li><em>why does it have to be finite?</em><br>
            Computers (and compilers) are finite machines. They can only hold and process finite amounts of data. If we have infinite number of non-terminals<br>
            </li>
        </ol>
    </li>
    <li><em><strong>Σ</strong> a set of terminal symbols (disjoint from N)</em><br>
    We’ve already understood what terminal symbols are, but what does <em>disjoint from NM</em> mean? N is the set of non-terminal symbols, as we’ve seen before, and the set of terminal symbols Σ cannot contain any elements from N. This implies that N and Σ are disjoint sets, they have no elements in common.
    </li>
    <li><em><strong>P</strong> a set of production rules</em><br>
    A <strong>production</strong> (also called a production rule) is a single rule within the grammar that tells how a non-terminal can be replaced (or "expanded") into a sequence of terminals and/or other non-terminals. We have already looked at an example of a set of productions. Consider the earlier example: <code>print(3+5)</code>. We can define a production rule to read the program as follows:
    <pre><code>Program    --> Statement<br>Statement  --> "print" "(" Expression ")"<br>Expression --> Term "+" Term<br>Term       --> number</code></pre>
    These are what we call <strong>production rules</strong>.
    </li>
    <li><em><strong>S ∈ N</strong> the start symbol</em><br>
    <strong>S</strong> is one of the important specification which indicates the starting point of any scan operations. Also <strong>S</strong> should belong to N (set of non-terminal symbols), which implies that <strong>S</strong> is a subset of <strong>N</strong>
    </li><br>
    Wow! Just one simple sentence carried this much weight?!
</ol>

All of this looks very complicated. Do we really need to build all of it just to perform a simple task that might not even require everything? <br>
__NO!__




